package com.greedy.section01.extend;

public class FireCar extends Car {
	
	/* Car 클래스를 부모 클래스로, FireCar 클래스를 자식 클래스로 사용한다. 
	 * 클래스 선언부에 extends Car를 추가하면 FireCar 클래스는 부모 클래스인 Car가 가지고 있는 모든 멤버를 상속 받는다.
	 * 하지만 생성자는 상속 받지 못한다. 또한 부모가 가지고 있는 private 멤버는 접근이 불가능하다.
	 * 
	 * 자바에서 상속은 기본적으로 부모가 가진 멤버를 자식이 사용할 수 있는 것이지만
	 * 더 나아가서 부모 클래스의 확장(extend)의 개념을 가진다.
	 * 추가적인 자신의 멤버 작성이 가능하며 메소드 재정의(overriding)라는 기술을 이용해서
	 * 부모가 가진 메소드를 재정의 하는 것도 가능하다.
	 * */
	
	/* 기본 생성자 */
	public FireCar() {
		
		/* 모든 생성자는 맨 첫 줄에 super(); 를 컴파일러가 자동으로 추가한다.
		 * 부모의 기본 생성자를 호출하는 구문이다.
		 * 따라서 출력 시 Car 클래스의 기본 생성자 호출됨... 이 먼저 출력 되는 것이다.
		 * 명시적, 묵시적 모두 가능하다.*/
		super();
		
		System.out.println("FireCar 클래스의 기본 생성자 호출 됨...");
	}
	
	/* 소방차의 경적 소리가 너무 작으므로 조금 더 키워보자. 
	 * 경적 소리를 내는 용도의 메소드 선언부는 그대로 두되 소방차 쪽에서 재정의 한다. */
	
	/* @Override 어노테이션
	 * JDK 1.5부터 추가 된 문법으로 오버라이딩 성립 요건을 체크하여 성립 되지 않은 경우 컴파일 에러를 발생시킨다. */
	@Override
	public void soundHorn() {
		
		/* 부모 클래스가 가진 메소드의 접근 제한자가 private일 때는 자식 클래스에서 호출 불가하지만
		 * protected로 변경하면 상속 관계에 있기 때문에 호출 가능해진다. */
		if(isRunning()) {
			System.out.println("빠아아아아아앙~!!!!!");
		} else {
			System.out.println("소방차가 앞으로 갈 수 없습니다~ 비키세요~");
		}
		
	}
	
	/* 자식 클래스만 가지는 기능을 추가적으로 정의할 수 있다. - 물 뿌리는 기능 */
	public void sprayWater() {
		System.out.println("불난 곳을 발견했습니다. 물을 뿌립니다. ==================>>>");
	}
	
	
	
	
	
	
	
	
	

}
